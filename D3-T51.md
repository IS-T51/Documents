---
pdf_options:
    format: a4
    margin: 30mm 20mm
    printBackground: true
    headerTemplate: |-
        <style>
            section {
                margin: 0 auto;
                font-family: system-ui;
                font-size: 11px;
            }
        </style>
        <section>
            D3 - Animati - Architettura v0.1 [pre-release]
        </section>
    footerTemplate: |-
        <section>
            <div>
                Pagina <span class="pageNumber"></span>
                di <span class="totalPages"></span>
            </div>
        </section>
---
<img alt="Università degli Studi di Trento" src="https://www.agenziagiornalisticaopinione.it/wp-content/uploads/2019/09/Logo-UniTrento-2019.jpg" width="45%" /> Dipartimento di Ingegneria e Scienza dell’Informazione

---

### Progetto:
<h1 align="center">Animati</h1>

<center><img alt="Logo" src="https://github.com/IS-T51/animati/blob/main/assets/img/logo.svg?raw=true" width="75%" /></center>

### Titolo del documento:
<h1 align="center">Architettura</h1>

### Gruppo:
<h1 align="center">T51</h1>

<div class="page-break"></div>

# Indice
<span class=horizontal_dotted_line>Diagramma delle Classi<span class=dot></span>3</span>
<span class=horizontal_dotted_line>OCL<span class=dot></span>?</span>

<style>
.horizontal_dotted_line{
    width: 100%;
    display : flex;
}
.dot{
    flex: 1;
    border-bottom: 2px dotted black;
    margin-left: 5px;
    margin-right: 5px;
    height: 1em;
}
</style>
<div class="page-break"></div>

# Scopo del documento
[...]

<div class="page-break"></div>

# Diagramma delle classi
Nel presente capitolo vengono presentate le classi previste nell'ambito del progetto Animati. Vengono riportate di seguito le classi individuate a partire dai diagrammi di contesto e dei componenti.

## Classi enumerative di supporto
### Unità
> La classe **Unità** è una classe di supporto utilizzata nella classe Info, che sta ad indicare con i suoi attributi la durata di un'attività.
### Ruolo
> La classe **Ruolo** è una classe di supporto utilizzata nella classe Utente, che sta ad indicare con i suoi attributi il ruolo assunto da uno specifico utente.
### Formato
> La classe **Formato** è una classe di supporto utilizzata ogniqualvolta si deve indicare il formato di un file da esportare. In questo caso nella classe ListaAttività, quando viene esportata una lista col metodo esporta(formato : Formato).
### TipoDado
> La classe **TipoDado** è una classe di supporto utilizzata nella classe Dado, che sta ad indicare con i suoi attributi il tipo di faccia utilizzata dallo strumento dado.
### MetodoDivisione
> La classe **MetodoDivisione** è una classe di supporto utilizzata nella classe CreazioneSquadre, che sta ad indicare con i suoi attributi la metodologia di divisione scelta dall'utente per l'estrazione delle squadre.
### Stato
> La classe **Stato** è una classe di supporto utilizzata nelle classi Cronometro e Timer, che serve per descrivere lo stato in cui si trovano gli stessi.

## Classi di supporto
### Data
> La classe **Data** è una classe di supporto che con i suoi attributi giorno, mese, anno, orario sta ad indicare un preciso momento e che grazie al suo attributo now() restituisce i valori di questi attributi.
### URL
> La classe **URL** è una classe di supporto che con i suoi attributi protocollo e percorso va ad indicare un immagine o un suono, a seconda dell'uso che si fa della classe.<br>
> Per esempio, nella classe Suono, l'url utilizzato per l'attributo sorgente rappresenta un suono. Al contrario, nelle classi Faccia e Utente, l'attributo immagine rappresenta, come indicato dal nome, un'immagine.
### Time
> La classe **Time** è una classe di supporto che con i suoi attributi, va a rappresentare un tempo con la precisione massima nell'ordine dei centesimi di secondo.
### Colore
> La classe **Colore** è una classe di supporto che con i suoi attributi, va a rappresentare un colore espresso tramite codice RGB, uno spazio di colore che riproduce i colori visibili all’uomo tramite la mescolanza additiva dei tre colori di base: rosso, verde e blu.
### Info, Filtro ed Etichetta
> La classe **Etichetta** è una classe di supporto che con i suoi attributi, va a rappresentare nome, descrizione e categoria di un'etichettà che può essere assegnata ad un'attività. Viene usata nella classe Info.<br>
> La classe **Info** è una classe di supporto che con i suoi attributi va a definire tutte le informazioni riguardanti un'attività.<br>
> La classe **Filtro** è una classe di supporto ed è collegata tramite una generalizzazione alla classe Info. Viene utilizzata per contenere le informazioni secondo le quali le attività devono essere filtrate.

## Dado e Faccia
> La classe **Faccia** è una classe di supporto alla classe Dado, e presenta tutti gli attributi necessari a definire qual è il tipo di una faccia del dado e cosa vi è rappresentato.
> La classe **Dado** è una classe il quale compito è quello di fornire gli attributi e i metodi necessari all'utilizzo dello strumento dado. <br>
> Una volta determinati i parametri definiti dagli attributi, grazie ai metodi presenti, il metodo estrai() è quello che fa funzionare lo strumento.
## Cronometro
> La classe **Cronometro** è una classe il quale compito è quello di fornire gli attributi e i metodi necessari all'utilizzo dello strumento cronometro.<br>
> Il tempo viene rappresentato grazie alla classe di supporto Time.
## Timer e Suono
> La classe **Suono** è una classe il quale compito è quello di fornire gli attributi e i metodi necessari all'utilizzo dello strumento fischietto, nonché di essere una classe di supporto alla classe Timer.<br>
> La classe **Suono**, grazie ai suoi attributi e metodi riesce a riprodurre un suono in base a come viene gestito l'attributo booleano inRiproduzione.<br>
> La classe **Timer** è una classe il quale compito è quello di fornire gli attributi e i metodi necessari all'utilizzo dello strumento timer.<br>
> I metodi stop() e start() di Timer hanno una funzione diversa rispetto a quelli di Suono, in quanto si occupano di fermare e avviare il timer e non di riprodurre o meno il suono.
## CreazioneSquadre
> La classe **CreazioneSquadre** è una classe il quale compito è quello di fornire gli attributi e i metodi necessari all'utilizzo dello strumento creazione squadre.<br>
> Gli attributi presenti indicano i valori dei parametri come anche se quei parametri sono stati impostati, nel caso degli attributi booleani Set.<br>
> Grazie ai metodi presenti viene poi fatta l'estrazione delle squadre, secondo la metodologia scelta dall'utente.
## SegnaPunti
> La classe **SegnaPunti** è una classe il quale compito è quello di fornire gli attributi e i metodi necessari all'utilizzo dello strumento segna punti.<br>
> L'attributo contatori rappresenta i contatori delle varie squadre, che vengono incrementati e/o decrementati grazie ai metodi presenti.
## Utente
> La classe **Utente** è una classe che rappresenta colui che utilizza l'applicazione. Ci sono quindi attributi che rappresentano i dati identificativi di quell'utente, come anche il ruolo e lo stato, che può essere offline o online.<br>
> Il metodo login() crea un'istanza di Autenticazione<br>
> Un utente può promuovere gli altri utenti, ma l'attributo promossoDa, serve nel caso un utente voglia declassare un altro utente che ha il ruolo di amministratore. In tal caso, l'utente deve essere quello che lo ha promosso a tale.<br>
> Un utente può creare una o più attività e/o liste di attività, rappresentate rispettivamente dalle classi Attività e ListaAttività.<br>
> Un utente può effettuare una o più segnalazioni e/o valutazioni, rappresentate rispettivamente dalle classi Segnalazione e Valutazione.
## Autenticazione
> La classe **Autenticazione** è una classe che rappresenta il processo di login di un utente. <br>
> Quando viene chiamato il metodo login() della classe Utente, viene creata un'istanza di Autenticazione e viene chiamata richiestaAutorizzativa().<br>
> Se il codice è valido viene chiamato il metodo richiestaToken() e successivamente dettagliAccount() che mette i risultati negli attributi id e mail dell'utente. <br>
> Viene chiesto a MongoDB il ruolo dell'utente e la sua foto profilo che vengono a loro volta assegnati agli attributi ruolo e immagine dell'utente.<br>
> Infine avviene un aggiornamento dei dati locali.
## Segnalazione
> La classe **Segnalazione** è una classe che rappresenta la segnalazione fatta da un utente ad un'attività. Più segnalazioni possono riferirsi ad una stessa attività. Ogni segnalazione è stata effettuata da un solo utente. <br>
> Gli attributi rappresentano le informazioni relative alla segnalazione, ovvero descrizione, utente da cui è stata fatta e attività alla quale si riferisce. <br>
> Un utente può effettuare una segnalazione grazie al metodo presente.<br>
> Se un utente non esiste più le segnalazioni effettuate dallo stesso rimangono.
## Valutazione
> La classe **Valutazione** è una classe che rappresenta la valutazione fatta da un utente ad un'attività. Più valutazioni possono riferirsi ad una stessa attività. Un utente può dare una sola valutazione ad un'attività. <br>
> Gli attributi rappresentano le informazioni relative alla valutazione, ovvero il voto espresso con un numero intero, l'attività a cui si riferisce e l'utente da cui è stata fatta. <br>
> Un utente può effettuare una segnalazione grazie al metodo presente. <br>
> Se un utente non esiste più le valutazioni effettuate dallo stesso rimangono.
## GestoreDatiOffline
## Attività
## Catalogo
## ListaAttività
## MongoDB


<div class="page-break"></div>

# Codice in Object Constraint Language
In questo capitolo è descritta in modo formale la logica prevista nell’ambito di alcune operazioni di alcune classi. Tale logica viene descritta in Object Constraint Language (OCL) perché tali concetti non sono esprimibili in nessun altro modo formale nel contesto di UML.

## **Cronometro**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | ---|
|start()|**stato** deve essere in "reset" o in "pause"|**stato** assume valore "run"|
|pause()|**stato** deve essere in "run"|**stato** assume valore "pause"|
|stop()|**stato** deve essere in "pause"|<ul><li>**stato** assume valore "reset"</li><li>**parziali** è una lista vuota</li></ul>|
|parziale()|**stato** deve essere in "run"|<ul><li>**stato** rimane al valore "run"</li><li>aggiunto tempo a lista **parziali**</li></ul>|

```js
context Cronometro::start()
pre: (self.stato = "reset") OR (self.stato = "pause")
post: self.stato = "run"
```
```js
context Cronometro::pause()
pre: self.stato = "run"
post: self.stato = "pause"
```
```js
context Cronometro::stop()
pre: self.stato = "pause"
post: (self.stato = "reset") AND (self.parziali -> isEmpty())
```
```js
context Cronometro::parziale()
pre: self.stato = "run"
post: (self.stato = "run") AND (self.parziali -> size() = self.parziali@pre -> size()+1) AND (self.parziali -> includes (self.tempo))
```

---

## **Segna-Punti**

#### contatori : Tuple{nome : String, punteggio : int}[0..N]
#### **Invarianti**:
- contatori contiente al più 99 elementi

```js
context Segna-Punti inv :
contatori -> size() <= 99
```

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|aggiungiContatore(nome : String)|<ul><li>il nome non può eccedere i 99 caratteri</li><li>il numero di squadre può essere al massimo 98</li><ul>|il valore del contatore col nome scelto è pari a 0|
|incrementa(nome : String)|il contatore può assumere valore minore di 500|il contatore col nome scelto viene incrementato di 1|
|decrementa(nome : String)|il contatore può assumere valore maggiore di -500|il contatore col nome scleto viene decrementato di 1|

```js
context Segna-Punti::aggiungiContatore(nome : String)
pre: (nome -> size() <= 99) AND (self.contatori -> size() <= 98)
post: self.contatori[nome] = 0
```
```js
context Segna-Punti::incrementa(nome : String)
pre: self.contatori[nome] < 500
post: self.contatori[nome] = self.contatori[nome]@pre + 1
```
```js
context Segna-Punti::decrementa(nome : String)
pre: self.contatori[nome] > -500
post: self.contatori[nome] = self.contatori[nome]@pre - 1
```
---

## **Timer**
#### stato : Enum
#### **Invarianti**
- stato assume i valori "reset", "run", "pause"

```js
context Timer inv :
(stato = "reset") OR (stato = "run") OR (stato = "pause")
```

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|start()|**stato** deve essere in "reset"|**stato** assume valore "run"|
|riprendi()|**stato** deve essere in "pause"|**stato** assume valore "run"|
|stop()|**stato** deve essere in "run"|**stato** assume valore "pause"|
|annulla()|**stato** deve essere in "pause"|**stato** assume valore "reset"|
|imposta(tempo : Time)| il tempo fonito deve essere positivo | **tempo** assume valore del tempo fornito|
|scegliSuono(suono : URL)| | la sorgente del suono è quella scelta|

```js
context Timer::start()
pre: self.stato = "reset"
post: self.stato = "run"
```
```js
context Timer::riprendi()
pre: self.stato = "pause"
post: self.stato = "run"
```
```js
context Timer::stop()
pre: self.stato = "run"
post: (self.stato = "pause")
```
```js
context Timer::annulla()
pre: self.stato = "pause"
post: self.stato = "reset"
```
```js
context Timer::imposta(tempo : Time)
pre: tempo > 0
post: self.tempo = tempo
```
```js
context Timer::scegliSuono(sorgente : URL)
post: self.suono.sorgente = sorgente
```
---

## **Dado**
#### tipo : Enum
#### **Invarianti**:
- tipo assume i valori "Numeri", "Colori", "Immagini"

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|estrai() : Object|<ul><li>se riestrazione assume il valore "False" l'utente non può estrarre un numero maggiore degli elementi selezionati</li><li>deve venire selezionato il tipo di oggetto estratto</li></ul>|vengono estratti gli elementi del tipo selezionato|
|cambiaModalità(riestrazione : bool)||l'attributo riestrazione viene impostato al valore selezionato|
|scegliTipo(tipo : Enum)||l'attributo tipo viene impostato al valore selezionato|
|aggiungi(oggetto : Object)||viene aggiunto un oggetto alla lista di quelli selezionabili|
---

// TODO: @teopan21

---
## **Suono**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|start()|premuto deve assumere il valore "True"|il suono è in riproduzione|
|stop()|premuto deve assumere il valore "False"|il suono non è in riproduzione|
|scegliSuono()||lla sorgente del suono è quella scelta|
---

```js
context Fischietto::start()
pre: NOT self.premuto
post: self.suono.inRiproduzione = true
```
```js
context Fischietto::stop()
pre: self.premuto
post: self.suono.inRiproduzione = false
```
```js
context Fischietto::scegliSuono(sorgente : URL)
post: self.suono.sorgente = sorgente
```

## **Creazione Squadre**
#### metodo : Enum
#### **Invarianti**:
- metodo assume i valori "Round robin", "Random", "Fill first" e "Balanced"

```js
context Creazione Squadre inv :
(stato = "Round robin") OR (stato = "Random") OR (stato = "Fill first") OR (stato = "Balanced")
numeroSquadre <= 99
numeroComponeti <= 99
numeroPartecipanti <= 9801
```

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|inserisciNumSquadre(numero : int)|numeroSquadre deve essere minore di 99|informazioni viene incrementato di 1|
|inserisciNumComponenti(numero : int)|numeroComponenti deve essere minore di 99|informazioni viene incrementato di 1|
|inserisciNumPartecipanti(numero : int)|numeroPartecipanti deve essere minore di 9801|informazioni viene incrementato di 1|
|scegliMetodo(metodo : Enum)||l'attributo metodo viene impostato con quello scelto|
|inserisciNome(nome : String)|la lunghezza dei nomi non deve eccedere i 99 caratteri|l'attributo nomi viene impostato con i nomi scelti|
|estrai()|<ul><li>informazioni deve essere uguale a 2 o 3</li><li>nel caso i tre valori: numeroSquadre, numeroPartecipanti e numeroComponenti non siano compatibili, verranno solamente considerati numeroPartecipanti e numeroSquadre.</ul>|<ul><li>se metodo assume il valore "Random" l'ordine delle squadre assegnate sarà completamente casuale</li><li>se metodo assume il valore "Round robin" l'assegnamento delle squadre sarà sequenziale</li><li>se il metodo assume il valore "Fill first" l'assegnamento avverrà per completamento delle squadre, ovvero riempiendo i posti di ogni squadra prima di procedere con l'assegnamento per la prossima</li><li>se il metodo assume il valore "Balanced" tutte le squadre dovranno avere lo stesso numero di partecipanti prima di procedere con gli assegnamenti</li><li>qualsiasi sia il metodo scelto, ogni volta che un partecipante viene assegnato ad una squadra il contatore di quella squadra viene incrementato di 1</li></ul>|
---

## **Utente**
#### ruolo : Enum
#### **Invarianti**:
- ruolo assume i valori "Amministratore" e "Base"
```js
context Utente inv :
(ruolo = "Amministratore") OR (ruolo = "Base")
```

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|cambiaRuolo(utente, promotore, nuovoRuolo)|<ul><li>un amministratore può essere declassato a utente comune unicamente dall’amministratore che lo ha promosso</li><li>se l'attributo ruolo dell'utente ha il valore "Amministratore", il suo ruolo può essere cambiato solo se promotore è diverso dall'attributo promossoDa dell'utente</li><li>il promotore deve avere ruolo "Amministratore"</li></ul>|l'attributo ruolo dell'utente assume il valore di nuovoRuolo|
---

## **Autenticazione**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|verificaOAuth()|||
|generaToken()|||
|ottieniUtente() : Utente|||
|logout()|||
---

// TODO: @teopan21

---
## **Catalogo**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|aggiornaCatalogo() : Attività[0...N]||l'attributo ultimoAggiornamento assume il valore della data corrente|
|filtra(cerca : String, etichette : Etichette[0...N]) : Attività[0...N]|<ul><li>nella barra di ricerca del titolo non si possono inserire più di 20 caratteri</li><li>i due valori della durata media sono compresi tra 0 e 999, sono interi e il primo è minore del secondo</li><li>il numero di partecipanti non può superare 99</li></ul>|il catalogo viene filtrato secondo le etichette previste|
|creaAttività(attività : Attività)|<ul><li>la descrizione non può superare i 2000 caratteri</li><li>i due valori della durata media sono compresi tra 0 e 999, sono interi e il primo è minore del secondo</li><li>il numero di partecipanti non può superare 99</li><li>il titolo non può superare i 20 caratteri di lunghezza</li></ul>|viene aggiunta una nuova attività al catalogo|
---

```js
context Catalogo::aggiornaCatalogo()
post: self.ultimoAggiornamento = Data.now()
```
// TODO: @teopan21

---
## **Lista di Attività**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|creaLista() : listaAttivita|<ul><li>il nome della lista di attività non può superare i 20 caratteri di lunghezza</li><li>un utente non può creare più di 99 liste di attività</li><li>il nome della lista di attività non può essere uguale al nome di un'altra lista già presente</li><li>il nome della lista di attività non può essere nessuno</li></ul>|viene creata una nuova lista di attività|
|aggiungiAttività(attività : Attività)|il numero di attività in una lista non può superare 9999|l'attività scelta viene aggiunta alla lista|
|esporta(formato : String) : File||la lista viene esportata in formato pdf o json|
|eliminaAttività(indice : int)||l'attività con l'indice scelto viene rimossa dalla lista|
---

// TODO: @teopan21

---
## **Attività**

// TODO: @teopan21 Invarianti

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|modifica(attivitàModificata : Attività)|<ul><li>la descrizione non può superare i 2000 caratteri</li><li>i due valori della durata media sono compresi tra 0 e 999, sono interi e il primo è minore del secondo</li><li>il numero di partecipanti non può superare 99</li><li>il titolo non può superare i 20 caratteri di lunghezza</li></ul>|<ul><li>tutti gli attributi assumono il valore dell'attività modificata</li><li>l'attributo ultimaModifica assume il valore della data corrente</li></ul>|
---

## **Segnalazione**

// TODO: @teopan21 invarianti

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|inviaSegnala(autore : Utente, attività : Attività, voto : String)|l'attributo messaggio non può superare i 500 caratteri di lunghezza|viene aggiunta una segnalazione per l'attività scelta|
---

## **Valutazione**

// TODO: @teopan21 invarianti

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
|inviaValutazione(autore : Utente, attività : Attività, voto : String)|il voto inserito deve essere un numero decimale compreso tra 0 e 5, con scarto di 0.5|<ul><li>viene aggiunta la valutazione all'attività scelta</li><li>cambia la media di voti dell'attività scelta</li>|
---


## **Feedback**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

## **GestoreDatiOffline**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

## **MongoDB**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

## **Info**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---


## **Filtro**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---


## **Faccia**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---


## **Colore**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---


## **URL**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

## **Data**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

## **Time**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

## **Etichetta**

| Metodo | Precondizioni | Postcondizioni |
| --- | --- | --- |
---

<div class="page-break"></div>
